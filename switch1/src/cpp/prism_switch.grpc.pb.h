// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: prism_switch.proto
#ifndef GRPC_prism_5fswitch_2eproto__INCLUDED
#define GRPC_prism_5fswitch_2eproto__INCLUDED

#include "prism_switch.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/method_handler_impl.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace grpc {
class CompletionQueue;
class Channel;
class ServerCompletionQueue;
class ServerContext;
} // namespace grpc

namespace prism {

class PrismSwitch final {
public:
  static constexpr char const *
  service_full_name()
  {
    return "prism.PrismSwitch";
  }
  class StubInterface {
  public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status Add(::grpc::ClientContext *context,
                               const ::prism::PrismSwitchAddReq &request,
                               ::prism::PrismSwitchReply *response) = 0;
    std::unique_ptr<
        ::grpc::ClientAsyncResponseReaderInterface<::prism::PrismSwitchReply>>
    AsyncAdd(::grpc::ClientContext *context,
             const ::prism::PrismSwitchAddReq &request,
             ::grpc::CompletionQueue *cq)
    {
      return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<
          ::prism::PrismSwitchReply>>(AsyncAddRaw(context, request, cq));
    }
    std::unique_ptr<
        ::grpc::ClientAsyncResponseReaderInterface<::prism::PrismSwitchReply>>
    PrepareAsyncAdd(::grpc::ClientContext *context,
                    const ::prism::PrismSwitchAddReq &request,
                    ::grpc::CompletionQueue *cq)
    {
      return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<
          ::prism::PrismSwitchReply>>(PrepareAsyncAddRaw(context, request, cq));
    }
    virtual ::grpc::Status
    ChangeOwner(::grpc::ClientContext *context,
                const ::prism::PrismSwitchChangeOwnerReq &request,
                ::prism::PrismSwitchReply *response) = 0;
    std::unique_ptr<
        ::grpc::ClientAsyncResponseReaderInterface<::prism::PrismSwitchReply>>
    AsyncChangeOwner(::grpc::ClientContext *context,
                     const ::prism::PrismSwitchChangeOwnerReq &request,
                     ::grpc::CompletionQueue *cq)
    {
      return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<
          ::prism::PrismSwitchReply>>(
          AsyncChangeOwnerRaw(context, request, cq));
    }
    std::unique_ptr<
        ::grpc::ClientAsyncResponseReaderInterface<::prism::PrismSwitchReply>>
    PrepareAsyncChangeOwner(::grpc::ClientContext *context,
                            const ::prism::PrismSwitchChangeOwnerReq &request,
                            ::grpc::CompletionQueue *cq)
    {
      return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<
          ::prism::PrismSwitchReply>>(
          PrepareAsyncChangeOwnerRaw(context, request, cq));
    }
    virtual ::grpc::Status Delete(::grpc::ClientContext *context,
                                  const ::prism::PrismSwitchDeleteReq &request,
                                  ::prism::PrismSwitchReply *response) = 0;
    std::unique_ptr<
        ::grpc::ClientAsyncResponseReaderInterface<::prism::PrismSwitchReply>>
    AsyncDelete(::grpc::ClientContext *context,
                const ::prism::PrismSwitchDeleteReq &request,
                ::grpc::CompletionQueue *cq)
    {
      return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<
          ::prism::PrismSwitchReply>>(AsyncDeleteRaw(context, request, cq));
    }
    std::unique_ptr<
        ::grpc::ClientAsyncResponseReaderInterface<::prism::PrismSwitchReply>>
    PrepareAsyncDelete(::grpc::ClientContext *context,
                       const ::prism::PrismSwitchDeleteReq &request,
                       ::grpc::CompletionQueue *cq)
    {
      return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<
          ::prism::PrismSwitchReply>>(
          PrepareAsyncDeleteRaw(context, request, cq));
    }
    virtual ::grpc::Status Lock(::grpc::ClientContext *context,
                                const ::prism::PrismSwitchLockReq &request,
                                ::prism::PrismSwitchReply *response) = 0;
    std::unique_ptr<
        ::grpc::ClientAsyncResponseReaderInterface<::prism::PrismSwitchReply>>
    AsyncLock(::grpc::ClientContext *context,
              const ::prism::PrismSwitchLockReq &request,
              ::grpc::CompletionQueue *cq)
    {
      return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<
          ::prism::PrismSwitchReply>>(AsyncLockRaw(context, request, cq));
    }
    std::unique_ptr<
        ::grpc::ClientAsyncResponseReaderInterface<::prism::PrismSwitchReply>>
    PrepareAsyncLock(::grpc::ClientContext *context,
                     const ::prism::PrismSwitchLockReq &request,
                     ::grpc::CompletionQueue *cq)
    {
      return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<
          ::prism::PrismSwitchReply>>(
          PrepareAsyncLockRaw(context, request, cq));
    }
    virtual ::grpc::Status Unlock(::grpc::ClientContext *context,
                                  const ::prism::PrismSwitchLockReq &request,
                                  ::prism::PrismSwitchReply *response) = 0;
    std::unique_ptr<
        ::grpc::ClientAsyncResponseReaderInterface<::prism::PrismSwitchReply>>
    AsyncUnlock(::grpc::ClientContext *context,
                const ::prism::PrismSwitchLockReq &request,
                ::grpc::CompletionQueue *cq)
    {
      return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<
          ::prism::PrismSwitchReply>>(AsyncUnlockRaw(context, request, cq));
    }
    std::unique_ptr<
        ::grpc::ClientAsyncResponseReaderInterface<::prism::PrismSwitchReply>>
    PrepareAsyncUnlock(::grpc::ClientContext *context,
                       const ::prism::PrismSwitchLockReq &request,
                       ::grpc::CompletionQueue *cq)
    {
      return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<
          ::prism::PrismSwitchReply>>(
          PrepareAsyncUnlockRaw(context, request, cq));
    }
    class experimental_async_interface {
    public:
      virtual ~experimental_async_interface() {}
      virtual void Add(::grpc::ClientContext *context,
                       const ::prism::PrismSwitchAddReq *request,
                       ::prism::PrismSwitchReply *response,
                       std::function<void(::grpc::Status)>) = 0;
      virtual void
      ChangeOwner(::grpc::ClientContext *context,
                  const ::prism::PrismSwitchChangeOwnerReq *request,
                  ::prism::PrismSwitchReply *response,
                  std::function<void(::grpc::Status)>) = 0;
      virtual void Delete(::grpc::ClientContext *context,
                          const ::prism::PrismSwitchDeleteReq *request,
                          ::prism::PrismSwitchReply *response,
                          std::function<void(::grpc::Status)>) = 0;
      virtual void Lock(::grpc::ClientContext *context,
                        const ::prism::PrismSwitchLockReq *request,
                        ::prism::PrismSwitchReply *response,
                        std::function<void(::grpc::Status)>) = 0;
      virtual void Unlock(::grpc::ClientContext *context,
                          const ::prism::PrismSwitchLockReq *request,
                          ::prism::PrismSwitchReply *response,
                          std::function<void(::grpc::Status)>) = 0;
    };
    virtual class experimental_async_interface *
    experimental_async()
    {
      return nullptr;
    }

  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface<
        ::prism::PrismSwitchReply> *
    AsyncAddRaw(::grpc::ClientContext *context,
                const ::prism::PrismSwitchAddReq &request,
                ::grpc::CompletionQueue *cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface<
        ::prism::PrismSwitchReply> *
    PrepareAsyncAddRaw(::grpc::ClientContext *context,
                       const ::prism::PrismSwitchAddReq &request,
                       ::grpc::CompletionQueue *cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface<
        ::prism::PrismSwitchReply> *
    AsyncChangeOwnerRaw(::grpc::ClientContext *context,
                        const ::prism::PrismSwitchChangeOwnerReq &request,
                        ::grpc::CompletionQueue *cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface<
        ::prism::PrismSwitchReply> *
    PrepareAsyncChangeOwnerRaw(
        ::grpc::ClientContext *context,
        const ::prism::PrismSwitchChangeOwnerReq &request,
        ::grpc::CompletionQueue *cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface<
        ::prism::PrismSwitchReply> *
    AsyncDeleteRaw(::grpc::ClientContext *context,
                   const ::prism::PrismSwitchDeleteReq &request,
                   ::grpc::CompletionQueue *cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface<
        ::prism::PrismSwitchReply> *
    PrepareAsyncDeleteRaw(::grpc::ClientContext *context,
                          const ::prism::PrismSwitchDeleteReq &request,
                          ::grpc::CompletionQueue *cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface<
        ::prism::PrismSwitchReply> *
    AsyncLockRaw(::grpc::ClientContext *context,
                 const ::prism::PrismSwitchLockReq &request,
                 ::grpc::CompletionQueue *cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface<
        ::prism::PrismSwitchReply> *
    PrepareAsyncLockRaw(::grpc::ClientContext *context,
                        const ::prism::PrismSwitchLockReq &request,
                        ::grpc::CompletionQueue *cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface<
        ::prism::PrismSwitchReply> *
    AsyncUnlockRaw(::grpc::ClientContext *context,
                   const ::prism::PrismSwitchLockReq &request,
                   ::grpc::CompletionQueue *cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface<
        ::prism::PrismSwitchReply> *
    PrepareAsyncUnlockRaw(::grpc::ClientContext *context,
                          const ::prism::PrismSwitchLockReq &request,
                          ::grpc::CompletionQueue *cq) = 0;
  };
  class Stub final : public StubInterface {
  public:
    Stub(const std::shared_ptr<::grpc::ChannelInterface> &channel);
    ::grpc::Status Add(::grpc::ClientContext *context,
                       const ::prism::PrismSwitchAddReq &request,
                       ::prism::PrismSwitchReply *response) override;
    std::unique_ptr<
        ::grpc::ClientAsyncResponseReader<::prism::PrismSwitchReply>>
    AsyncAdd(::grpc::ClientContext *context,
             const ::prism::PrismSwitchAddReq &request,
             ::grpc::CompletionQueue *cq)
    {
      return std::unique_ptr<
          ::grpc::ClientAsyncResponseReader<::prism::PrismSwitchReply>>(
          AsyncAddRaw(context, request, cq));
    }
    std::unique_ptr<
        ::grpc::ClientAsyncResponseReader<::prism::PrismSwitchReply>>
    PrepareAsyncAdd(::grpc::ClientContext *context,
                    const ::prism::PrismSwitchAddReq &request,
                    ::grpc::CompletionQueue *cq)
    {
      return std::unique_ptr<
          ::grpc::ClientAsyncResponseReader<::prism::PrismSwitchReply>>(
          PrepareAsyncAddRaw(context, request, cq));
    }
    ::grpc::Status
    ChangeOwner(::grpc::ClientContext *context,
                const ::prism::PrismSwitchChangeOwnerReq &request,
                ::prism::PrismSwitchReply *response) override;
    std::unique_ptr<
        ::grpc::ClientAsyncResponseReader<::prism::PrismSwitchReply>>
    AsyncChangeOwner(::grpc::ClientContext *context,
                     const ::prism::PrismSwitchChangeOwnerReq &request,
                     ::grpc::CompletionQueue *cq)
    {
      return std::unique_ptr<
          ::grpc::ClientAsyncResponseReader<::prism::PrismSwitchReply>>(
          AsyncChangeOwnerRaw(context, request, cq));
    }
    std::unique_ptr<
        ::grpc::ClientAsyncResponseReader<::prism::PrismSwitchReply>>
    PrepareAsyncChangeOwner(::grpc::ClientContext *context,
                            const ::prism::PrismSwitchChangeOwnerReq &request,
                            ::grpc::CompletionQueue *cq)
    {
      return std::unique_ptr<
          ::grpc::ClientAsyncResponseReader<::prism::PrismSwitchReply>>(
          PrepareAsyncChangeOwnerRaw(context, request, cq));
    }
    ::grpc::Status Delete(::grpc::ClientContext *context,
                          const ::prism::PrismSwitchDeleteReq &request,
                          ::prism::PrismSwitchReply *response) override;
    std::unique_ptr<
        ::grpc::ClientAsyncResponseReader<::prism::PrismSwitchReply>>
    AsyncDelete(::grpc::ClientContext *context,
                const ::prism::PrismSwitchDeleteReq &request,
                ::grpc::CompletionQueue *cq)
    {
      return std::unique_ptr<
          ::grpc::ClientAsyncResponseReader<::prism::PrismSwitchReply>>(
          AsyncDeleteRaw(context, request, cq));
    }
    std::unique_ptr<
        ::grpc::ClientAsyncResponseReader<::prism::PrismSwitchReply>>
    PrepareAsyncDelete(::grpc::ClientContext *context,
                       const ::prism::PrismSwitchDeleteReq &request,
                       ::grpc::CompletionQueue *cq)
    {
      return std::unique_ptr<
          ::grpc::ClientAsyncResponseReader<::prism::PrismSwitchReply>>(
          PrepareAsyncDeleteRaw(context, request, cq));
    }
    ::grpc::Status Lock(::grpc::ClientContext *context,
                        const ::prism::PrismSwitchLockReq &request,
                        ::prism::PrismSwitchReply *response) override;
    std::unique_ptr<
        ::grpc::ClientAsyncResponseReader<::prism::PrismSwitchReply>>
    AsyncLock(::grpc::ClientContext *context,
              const ::prism::PrismSwitchLockReq &request,
              ::grpc::CompletionQueue *cq)
    {
      return std::unique_ptr<
          ::grpc::ClientAsyncResponseReader<::prism::PrismSwitchReply>>(
          AsyncLockRaw(context, request, cq));
    }
    std::unique_ptr<
        ::grpc::ClientAsyncResponseReader<::prism::PrismSwitchReply>>
    PrepareAsyncLock(::grpc::ClientContext *context,
                     const ::prism::PrismSwitchLockReq &request,
                     ::grpc::CompletionQueue *cq)
    {
      return std::unique_ptr<
          ::grpc::ClientAsyncResponseReader<::prism::PrismSwitchReply>>(
          PrepareAsyncLockRaw(context, request, cq));
    }
    ::grpc::Status Unlock(::grpc::ClientContext *context,
                          const ::prism::PrismSwitchLockReq &request,
                          ::prism::PrismSwitchReply *response) override;
    std::unique_ptr<
        ::grpc::ClientAsyncResponseReader<::prism::PrismSwitchReply>>
    AsyncUnlock(::grpc::ClientContext *context,
                const ::prism::PrismSwitchLockReq &request,
                ::grpc::CompletionQueue *cq)
    {
      return std::unique_ptr<
          ::grpc::ClientAsyncResponseReader<::prism::PrismSwitchReply>>(
          AsyncUnlockRaw(context, request, cq));
    }
    std::unique_ptr<
        ::grpc::ClientAsyncResponseReader<::prism::PrismSwitchReply>>
    PrepareAsyncUnlock(::grpc::ClientContext *context,
                       const ::prism::PrismSwitchLockReq &request,
                       ::grpc::CompletionQueue *cq)
    {
      return std::unique_ptr<
          ::grpc::ClientAsyncResponseReader<::prism::PrismSwitchReply>>(
          PrepareAsyncUnlockRaw(context, request, cq));
    }
    class experimental_async final
        : public StubInterface::experimental_async_interface {
    public:
      void Add(::grpc::ClientContext *context,
               const ::prism::PrismSwitchAddReq *request,
               ::prism::PrismSwitchReply *response,
               std::function<void(::grpc::Status)>) override;
      void ChangeOwner(::grpc::ClientContext *context,
                       const ::prism::PrismSwitchChangeOwnerReq *request,
                       ::prism::PrismSwitchReply *response,
                       std::function<void(::grpc::Status)>) override;
      void Delete(::grpc::ClientContext *context,
                  const ::prism::PrismSwitchDeleteReq *request,
                  ::prism::PrismSwitchReply *response,
                  std::function<void(::grpc::Status)>) override;
      void Lock(::grpc::ClientContext *context,
                const ::prism::PrismSwitchLockReq *request,
                ::prism::PrismSwitchReply *response,
                std::function<void(::grpc::Status)>) override;
      void Unlock(::grpc::ClientContext *context,
                  const ::prism::PrismSwitchLockReq *request,
                  ::prism::PrismSwitchReply *response,
                  std::function<void(::grpc::Status)>) override;

    private:
      friend class Stub;
      explicit experimental_async(Stub *stub) : stub_(stub) {}
      Stub *
      stub()
      {
        return stub_;
      }
      Stub *stub_;
    };
    class experimental_async_interface *
    experimental_async() override
    {
      return &async_stub_;
    }

  private:
    std::shared_ptr<::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_ {
      this
    };
    ::grpc::ClientAsyncResponseReader<::prism::PrismSwitchReply> *
    AsyncAddRaw(::grpc::ClientContext *context,
                const ::prism::PrismSwitchAddReq &request,
                ::grpc::CompletionQueue *cq) override;
    ::grpc::ClientAsyncResponseReader<::prism::PrismSwitchReply> *
    PrepareAsyncAddRaw(::grpc::ClientContext *context,
                       const ::prism::PrismSwitchAddReq &request,
                       ::grpc::CompletionQueue *cq) override;
    ::grpc::ClientAsyncResponseReader<::prism::PrismSwitchReply> *
    AsyncChangeOwnerRaw(::grpc::ClientContext *context,
                        const ::prism::PrismSwitchChangeOwnerReq &request,
                        ::grpc::CompletionQueue *cq) override;
    ::grpc::ClientAsyncResponseReader<::prism::PrismSwitchReply> *
    PrepareAsyncChangeOwnerRaw(
        ::grpc::ClientContext *context,
        const ::prism::PrismSwitchChangeOwnerReq &request,
        ::grpc::CompletionQueue *cq) override;
    ::grpc::ClientAsyncResponseReader<::prism::PrismSwitchReply> *
    AsyncDeleteRaw(::grpc::ClientContext *context,
                   const ::prism::PrismSwitchDeleteReq &request,
                   ::grpc::CompletionQueue *cq) override;
    ::grpc::ClientAsyncResponseReader<::prism::PrismSwitchReply> *
    PrepareAsyncDeleteRaw(::grpc::ClientContext *context,
                          const ::prism::PrismSwitchDeleteReq &request,
                          ::grpc::CompletionQueue *cq) override;
    ::grpc::ClientAsyncResponseReader<::prism::PrismSwitchReply> *
    AsyncLockRaw(::grpc::ClientContext *context,
                 const ::prism::PrismSwitchLockReq &request,
                 ::grpc::CompletionQueue *cq) override;
    ::grpc::ClientAsyncResponseReader<::prism::PrismSwitchReply> *
    PrepareAsyncLockRaw(::grpc::ClientContext *context,
                        const ::prism::PrismSwitchLockReq &request,
                        ::grpc::CompletionQueue *cq) override;
    ::grpc::ClientAsyncResponseReader<::prism::PrismSwitchReply> *
    AsyncUnlockRaw(::grpc::ClientContext *context,
                   const ::prism::PrismSwitchLockReq &request,
                   ::grpc::CompletionQueue *cq) override;
    ::grpc::ClientAsyncResponseReader<::prism::PrismSwitchReply> *
    PrepareAsyncUnlockRaw(::grpc::ClientContext *context,
                          const ::prism::PrismSwitchLockReq &request,
                          ::grpc::CompletionQueue *cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_Add_;
    const ::grpc::internal::RpcMethod rpcmethod_ChangeOwner_;
    const ::grpc::internal::RpcMethod rpcmethod_Delete_;
    const ::grpc::internal::RpcMethod rpcmethod_Lock_;
    const ::grpc::internal::RpcMethod rpcmethod_Unlock_;
  };
  static std::unique_ptr<Stub>
  NewStub(const std::shared_ptr<::grpc::ChannelInterface> &channel,
          const ::grpc::StubOptions &options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
  public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status Add(::grpc::ServerContext *context,
                               const ::prism::PrismSwitchAddReq *request,
                               ::prism::PrismSwitchReply *response);
    virtual ::grpc::Status
    ChangeOwner(::grpc::ServerContext *context,
                const ::prism::PrismSwitchChangeOwnerReq *request,
                ::prism::PrismSwitchReply *response);
    virtual ::grpc::Status Delete(::grpc::ServerContext *context,
                                  const ::prism::PrismSwitchDeleteReq *request,
                                  ::prism::PrismSwitchReply *response);
    virtual ::grpc::Status Lock(::grpc::ServerContext *context,
                                const ::prism::PrismSwitchLockReq *request,
                                ::prism::PrismSwitchReply *response);
    virtual ::grpc::Status Unlock(::grpc::ServerContext *context,
                                  const ::prism::PrismSwitchLockReq *request,
                                  ::prism::PrismSwitchReply *response);
  };
  template <class BaseClass> class WithAsyncMethod_Add : public BaseClass {
  private:
    void
    BaseClassMustBeDerivedFromService(const Service *service)
    {
    }

  public:
    WithAsyncMethod_Add() { ::grpc::Service::MarkMethodAsync(0); }
    ~WithAsyncMethod_Add() override { BaseClassMustBeDerivedFromService(this); }
    // disable synchronous version of this method
    ::grpc::Status
    Add(::grpc::ServerContext *context,
        const ::prism::PrismSwitchAddReq *request,
        ::prism::PrismSwitchReply *response) override
    {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void
    RequestAdd(
        ::grpc::ServerContext *context, ::prism::PrismSwitchAddReq *request,
        ::grpc::ServerAsyncResponseWriter<::prism::PrismSwitchReply> *response,
        ::grpc::CompletionQueue *new_call_cq,
        ::grpc::ServerCompletionQueue *notification_cq, void *tag)
    {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response,
                                         new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ChangeOwner : public BaseClass {
  private:
    void
    BaseClassMustBeDerivedFromService(const Service *service)
    {
    }

  public:
    WithAsyncMethod_ChangeOwner() { ::grpc::Service::MarkMethodAsync(1); }
    ~WithAsyncMethod_ChangeOwner() override
    {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status
    ChangeOwner(::grpc::ServerContext *context,
                const ::prism::PrismSwitchChangeOwnerReq *request,
                ::prism::PrismSwitchReply *response) override
    {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void
    RequestChangeOwner(
        ::grpc::ServerContext *context,
        ::prism::PrismSwitchChangeOwnerReq *request,
        ::grpc::ServerAsyncResponseWriter<::prism::PrismSwitchReply> *response,
        ::grpc::CompletionQueue *new_call_cq,
        ::grpc::ServerCompletionQueue *notification_cq, void *tag)
    {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response,
                                         new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass> class WithAsyncMethod_Delete : public BaseClass {
  private:
    void
    BaseClassMustBeDerivedFromService(const Service *service)
    {
    }

  public:
    WithAsyncMethod_Delete() { ::grpc::Service::MarkMethodAsync(2); }
    ~WithAsyncMethod_Delete() override
    {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status
    Delete(::grpc::ServerContext *context,
           const ::prism::PrismSwitchDeleteReq *request,
           ::prism::PrismSwitchReply *response) override
    {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void
    RequestDelete(
        ::grpc::ServerContext *context, ::prism::PrismSwitchDeleteReq *request,
        ::grpc::ServerAsyncResponseWriter<::prism::PrismSwitchReply> *response,
        ::grpc::CompletionQueue *new_call_cq,
        ::grpc::ServerCompletionQueue *notification_cq, void *tag)
    {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response,
                                         new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass> class WithAsyncMethod_Lock : public BaseClass {
  private:
    void
    BaseClassMustBeDerivedFromService(const Service *service)
    {
    }

  public:
    WithAsyncMethod_Lock() { ::grpc::Service::MarkMethodAsync(3); }
    ~WithAsyncMethod_Lock() override
    {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status
    Lock(::grpc::ServerContext *context,
         const ::prism::PrismSwitchLockReq *request,
         ::prism::PrismSwitchReply *response) override
    {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void
    RequestLock(
        ::grpc::ServerContext *context, ::prism::PrismSwitchLockReq *request,
        ::grpc::ServerAsyncResponseWriter<::prism::PrismSwitchReply> *response,
        ::grpc::CompletionQueue *new_call_cq,
        ::grpc::ServerCompletionQueue *notification_cq, void *tag)
    {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response,
                                         new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass> class WithAsyncMethod_Unlock : public BaseClass {
  private:
    void
    BaseClassMustBeDerivedFromService(const Service *service)
    {
    }

  public:
    WithAsyncMethod_Unlock() { ::grpc::Service::MarkMethodAsync(4); }
    ~WithAsyncMethod_Unlock() override
    {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status
    Unlock(::grpc::ServerContext *context,
           const ::prism::PrismSwitchLockReq *request,
           ::prism::PrismSwitchReply *response) override
    {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void
    RequestUnlock(
        ::grpc::ServerContext *context, ::prism::PrismSwitchLockReq *request,
        ::grpc::ServerAsyncResponseWriter<::prism::PrismSwitchReply> *response,
        ::grpc::CompletionQueue *new_call_cq,
        ::grpc::ServerCompletionQueue *notification_cq, void *tag)
    {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response,
                                         new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_Add<
      WithAsyncMethod_ChangeOwner<WithAsyncMethod_Delete<
          WithAsyncMethod_Lock<WithAsyncMethod_Unlock<Service>>>>>
      AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Add : public BaseClass {
  private:
    void
    BaseClassMustBeDerivedFromService(const Service *service)
    {
    }

  public:
    ExperimentalWithCallbackMethod_Add()
    {
      ::grpc::Service::experimental().MarkMethodCallback(
          0,
          new ::grpc::internal::CallbackUnaryHandler<::prism::PrismSwitchAddReq,
                                                     ::prism::PrismSwitchReply>(
              [this](::grpc::ServerContext *context,
                     const ::prism::PrismSwitchAddReq *request,
                     ::prism::PrismSwitchReply *response,
                     ::grpc::experimental::ServerCallbackRpcController
                         *controller) {
                return this->Add(context, request, response, controller);
              }));
    }
    ~ExperimentalWithCallbackMethod_Add() override
    {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status
    Add(::grpc::ServerContext *context,
        const ::prism::PrismSwitchAddReq *request,
        ::prism::PrismSwitchReply *response) override
    {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void
    Add(::grpc::ServerContext *context,
        const ::prism::PrismSwitchAddReq *request,
        ::prism::PrismSwitchReply *response,
        ::grpc::experimental::ServerCallbackRpcController *controller)
    {
      controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, ""));
    }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ChangeOwner : public BaseClass {
  private:
    void
    BaseClassMustBeDerivedFromService(const Service *service)
    {
    }

  public:
    ExperimentalWithCallbackMethod_ChangeOwner()
    {
      ::grpc::Service::experimental().MarkMethodCallback(
          1, new ::grpc::internal::CallbackUnaryHandler<
                 ::prism::PrismSwitchChangeOwnerReq, ::prism::PrismSwitchReply>(
                 [this](::grpc::ServerContext *context,
                        const ::prism::PrismSwitchChangeOwnerReq *request,
                        ::prism::PrismSwitchReply *response,
                        ::grpc::experimental::ServerCallbackRpcController
                            *controller) {
                   return this->ChangeOwner(context, request, response,
                                            controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_ChangeOwner() override
    {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status
    ChangeOwner(::grpc::ServerContext *context,
                const ::prism::PrismSwitchChangeOwnerReq *request,
                ::prism::PrismSwitchReply *response) override
    {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void
    ChangeOwner(::grpc::ServerContext *context,
                const ::prism::PrismSwitchChangeOwnerReq *request,
                ::prism::PrismSwitchReply *response,
                ::grpc::experimental::ServerCallbackRpcController *controller)
    {
      controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, ""));
    }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Delete : public BaseClass {
  private:
    void
    BaseClassMustBeDerivedFromService(const Service *service)
    {
    }

  public:
    ExperimentalWithCallbackMethod_Delete()
    {
      ::grpc::Service::experimental().MarkMethodCallback(
          2, new ::grpc::internal::CallbackUnaryHandler<
                 ::prism::PrismSwitchDeleteReq, ::prism::PrismSwitchReply>(
                 [this](::grpc::ServerContext *context,
                        const ::prism::PrismSwitchDeleteReq *request,
                        ::prism::PrismSwitchReply *response,
                        ::grpc::experimental::ServerCallbackRpcController
                            *controller) {
                   return this->Delete(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_Delete() override
    {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status
    Delete(::grpc::ServerContext *context,
           const ::prism::PrismSwitchDeleteReq *request,
           ::prism::PrismSwitchReply *response) override
    {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void
    Delete(::grpc::ServerContext *context,
           const ::prism::PrismSwitchDeleteReq *request,
           ::prism::PrismSwitchReply *response,
           ::grpc::experimental::ServerCallbackRpcController *controller)
    {
      controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, ""));
    }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Lock : public BaseClass {
  private:
    void
    BaseClassMustBeDerivedFromService(const Service *service)
    {
    }

  public:
    ExperimentalWithCallbackMethod_Lock()
    {
      ::grpc::Service::experimental().MarkMethodCallback(
          3, new ::grpc::internal::CallbackUnaryHandler<
                 ::prism::PrismSwitchLockReq, ::prism::PrismSwitchReply>(
                 [this](::grpc::ServerContext *context,
                        const ::prism::PrismSwitchLockReq *request,
                        ::prism::PrismSwitchReply *response,
                        ::grpc::experimental::ServerCallbackRpcController
                            *controller) {
                   return this->Lock(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_Lock() override
    {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status
    Lock(::grpc::ServerContext *context,
         const ::prism::PrismSwitchLockReq *request,
         ::prism::PrismSwitchReply *response) override
    {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void
    Lock(::grpc::ServerContext *context,
         const ::prism::PrismSwitchLockReq *request,
         ::prism::PrismSwitchReply *response,
         ::grpc::experimental::ServerCallbackRpcController *controller)
    {
      controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, ""));
    }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Unlock : public BaseClass {
  private:
    void
    BaseClassMustBeDerivedFromService(const Service *service)
    {
    }

  public:
    ExperimentalWithCallbackMethod_Unlock()
    {
      ::grpc::Service::experimental().MarkMethodCallback(
          4, new ::grpc::internal::CallbackUnaryHandler<
                 ::prism::PrismSwitchLockReq, ::prism::PrismSwitchReply>(
                 [this](::grpc::ServerContext *context,
                        const ::prism::PrismSwitchLockReq *request,
                        ::prism::PrismSwitchReply *response,
                        ::grpc::experimental::ServerCallbackRpcController
                            *controller) {
                   return this->Unlock(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_Unlock() override
    {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status
    Unlock(::grpc::ServerContext *context,
           const ::prism::PrismSwitchLockReq *request,
           ::prism::PrismSwitchReply *response) override
    {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void
    Unlock(::grpc::ServerContext *context,
           const ::prism::PrismSwitchLockReq *request,
           ::prism::PrismSwitchReply *response,
           ::grpc::experimental::ServerCallbackRpcController *controller)
    {
      controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, ""));
    }
  };
  typedef ExperimentalWithCallbackMethod_Add<
      ExperimentalWithCallbackMethod_ChangeOwner<
          ExperimentalWithCallbackMethod_Delete<
              ExperimentalWithCallbackMethod_Lock<
                  ExperimentalWithCallbackMethod_Unlock<Service>>>>>
      ExperimentalCallbackService;
  template <class BaseClass> class WithGenericMethod_Add : public BaseClass {
  private:
    void
    BaseClassMustBeDerivedFromService(const Service *service)
    {
    }

  public:
    WithGenericMethod_Add() { ::grpc::Service::MarkMethodGeneric(0); }
    ~WithGenericMethod_Add() override
    {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status
    Add(::grpc::ServerContext *context,
        const ::prism::PrismSwitchAddReq *request,
        ::prism::PrismSwitchReply *response) override
    {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ChangeOwner : public BaseClass {
  private:
    void
    BaseClassMustBeDerivedFromService(const Service *service)
    {
    }

  public:
    WithGenericMethod_ChangeOwner() { ::grpc::Service::MarkMethodGeneric(1); }
    ~WithGenericMethod_ChangeOwner() override
    {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status
    ChangeOwner(::grpc::ServerContext *context,
                const ::prism::PrismSwitchChangeOwnerReq *request,
                ::prism::PrismSwitchReply *response) override
    {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass> class WithGenericMethod_Delete : public BaseClass {
  private:
    void
    BaseClassMustBeDerivedFromService(const Service *service)
    {
    }

  public:
    WithGenericMethod_Delete() { ::grpc::Service::MarkMethodGeneric(2); }
    ~WithGenericMethod_Delete() override
    {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status
    Delete(::grpc::ServerContext *context,
           const ::prism::PrismSwitchDeleteReq *request,
           ::prism::PrismSwitchReply *response) override
    {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass> class WithGenericMethod_Lock : public BaseClass {
  private:
    void
    BaseClassMustBeDerivedFromService(const Service *service)
    {
    }

  public:
    WithGenericMethod_Lock() { ::grpc::Service::MarkMethodGeneric(3); }
    ~WithGenericMethod_Lock() override
    {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status
    Lock(::grpc::ServerContext *context,
         const ::prism::PrismSwitchLockReq *request,
         ::prism::PrismSwitchReply *response) override
    {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass> class WithGenericMethod_Unlock : public BaseClass {
  private:
    void
    BaseClassMustBeDerivedFromService(const Service *service)
    {
    }

  public:
    WithGenericMethod_Unlock() { ::grpc::Service::MarkMethodGeneric(4); }
    ~WithGenericMethod_Unlock() override
    {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status
    Unlock(::grpc::ServerContext *context,
           const ::prism::PrismSwitchLockReq *request,
           ::prism::PrismSwitchReply *response) override
    {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass> class WithRawMethod_Add : public BaseClass {
  private:
    void
    BaseClassMustBeDerivedFromService(const Service *service)
    {
    }

  public:
    WithRawMethod_Add() { ::grpc::Service::MarkMethodRaw(0); }
    ~WithRawMethod_Add() override { BaseClassMustBeDerivedFromService(this); }
    // disable synchronous version of this method
    ::grpc::Status
    Add(::grpc::ServerContext *context,
        const ::prism::PrismSwitchAddReq *request,
        ::prism::PrismSwitchReply *response) override
    {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void
    RequestAdd(::grpc::ServerContext *context, ::grpc::ByteBuffer *request,
               ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer> *response,
               ::grpc::CompletionQueue *new_call_cq,
               ::grpc::ServerCompletionQueue *notification_cq, void *tag)
    {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response,
                                         new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ChangeOwner : public BaseClass {
  private:
    void
    BaseClassMustBeDerivedFromService(const Service *service)
    {
    }

  public:
    WithRawMethod_ChangeOwner() { ::grpc::Service::MarkMethodRaw(1); }
    ~WithRawMethod_ChangeOwner() override
    {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status
    ChangeOwner(::grpc::ServerContext *context,
                const ::prism::PrismSwitchChangeOwnerReq *request,
                ::prism::PrismSwitchReply *response) override
    {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void
    RequestChangeOwner(
        ::grpc::ServerContext *context, ::grpc::ByteBuffer *request,
        ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer> *response,
        ::grpc::CompletionQueue *new_call_cq,
        ::grpc::ServerCompletionQueue *notification_cq, void *tag)
    {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response,
                                         new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass> class WithRawMethod_Delete : public BaseClass {
  private:
    void
    BaseClassMustBeDerivedFromService(const Service *service)
    {
    }

  public:
    WithRawMethod_Delete() { ::grpc::Service::MarkMethodRaw(2); }
    ~WithRawMethod_Delete() override
    {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status
    Delete(::grpc::ServerContext *context,
           const ::prism::PrismSwitchDeleteReq *request,
           ::prism::PrismSwitchReply *response) override
    {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void
    RequestDelete(
        ::grpc::ServerContext *context, ::grpc::ByteBuffer *request,
        ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer> *response,
        ::grpc::CompletionQueue *new_call_cq,
        ::grpc::ServerCompletionQueue *notification_cq, void *tag)
    {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response,
                                         new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass> class WithRawMethod_Lock : public BaseClass {
  private:
    void
    BaseClassMustBeDerivedFromService(const Service *service)
    {
    }

  public:
    WithRawMethod_Lock() { ::grpc::Service::MarkMethodRaw(3); }
    ~WithRawMethod_Lock() override { BaseClassMustBeDerivedFromService(this); }
    // disable synchronous version of this method
    ::grpc::Status
    Lock(::grpc::ServerContext *context,
         const ::prism::PrismSwitchLockReq *request,
         ::prism::PrismSwitchReply *response) override
    {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void
    RequestLock(::grpc::ServerContext *context, ::grpc::ByteBuffer *request,
                ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer> *response,
                ::grpc::CompletionQueue *new_call_cq,
                ::grpc::ServerCompletionQueue *notification_cq, void *tag)
    {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response,
                                         new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass> class WithRawMethod_Unlock : public BaseClass {
  private:
    void
    BaseClassMustBeDerivedFromService(const Service *service)
    {
    }

  public:
    WithRawMethod_Unlock() { ::grpc::Service::MarkMethodRaw(4); }
    ~WithRawMethod_Unlock() override
    {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status
    Unlock(::grpc::ServerContext *context,
           const ::prism::PrismSwitchLockReq *request,
           ::prism::PrismSwitchReply *response) override
    {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void
    RequestUnlock(
        ::grpc::ServerContext *context, ::grpc::ByteBuffer *request,
        ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer> *response,
        ::grpc::CompletionQueue *new_call_cq,
        ::grpc::ServerCompletionQueue *notification_cq, void *tag)
    {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response,
                                         new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Add : public BaseClass {
  private:
    void
    BaseClassMustBeDerivedFromService(const Service *service)
    {
    }

  public:
    ExperimentalWithRawCallbackMethod_Add()
    {
      ::grpc::Service::experimental().MarkMethodRawCallback(
          0, new ::grpc::internal::CallbackUnaryHandler<::grpc::ByteBuffer,
                                                        ::grpc::ByteBuffer>(
                 [this](::grpc::ServerContext *context,
                        const ::grpc::ByteBuffer *request,
                        ::grpc::ByteBuffer *response,
                        ::grpc::experimental::ServerCallbackRpcController
                            *controller) {
                   this->Add(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_Add() override
    {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status
    Add(::grpc::ServerContext *context,
        const ::prism::PrismSwitchAddReq *request,
        ::prism::PrismSwitchReply *response) override
    {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void
    Add(::grpc::ServerContext *context, const ::grpc::ByteBuffer *request,
        ::grpc::ByteBuffer *response,
        ::grpc::experimental::ServerCallbackRpcController *controller)
    {
      controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, ""));
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ChangeOwner : public BaseClass {
  private:
    void
    BaseClassMustBeDerivedFromService(const Service *service)
    {
    }

  public:
    ExperimentalWithRawCallbackMethod_ChangeOwner()
    {
      ::grpc::Service::experimental().MarkMethodRawCallback(
          1, new ::grpc::internal::CallbackUnaryHandler<::grpc::ByteBuffer,
                                                        ::grpc::ByteBuffer>(
                 [this](::grpc::ServerContext *context,
                        const ::grpc::ByteBuffer *request,
                        ::grpc::ByteBuffer *response,
                        ::grpc::experimental::ServerCallbackRpcController
                            *controller) {
                   this->ChangeOwner(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_ChangeOwner() override
    {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status
    ChangeOwner(::grpc::ServerContext *context,
                const ::prism::PrismSwitchChangeOwnerReq *request,
                ::prism::PrismSwitchReply *response) override
    {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void
    ChangeOwner(::grpc::ServerContext *context,
                const ::grpc::ByteBuffer *request, ::grpc::ByteBuffer *response,
                ::grpc::experimental::ServerCallbackRpcController *controller)
    {
      controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, ""));
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Delete : public BaseClass {
  private:
    void
    BaseClassMustBeDerivedFromService(const Service *service)
    {
    }

  public:
    ExperimentalWithRawCallbackMethod_Delete()
    {
      ::grpc::Service::experimental().MarkMethodRawCallback(
          2, new ::grpc::internal::CallbackUnaryHandler<::grpc::ByteBuffer,
                                                        ::grpc::ByteBuffer>(
                 [this](::grpc::ServerContext *context,
                        const ::grpc::ByteBuffer *request,
                        ::grpc::ByteBuffer *response,
                        ::grpc::experimental::ServerCallbackRpcController
                            *controller) {
                   this->Delete(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_Delete() override
    {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status
    Delete(::grpc::ServerContext *context,
           const ::prism::PrismSwitchDeleteReq *request,
           ::prism::PrismSwitchReply *response) override
    {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void
    Delete(::grpc::ServerContext *context, const ::grpc::ByteBuffer *request,
           ::grpc::ByteBuffer *response,
           ::grpc::experimental::ServerCallbackRpcController *controller)
    {
      controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, ""));
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Lock : public BaseClass {
  private:
    void
    BaseClassMustBeDerivedFromService(const Service *service)
    {
    }

  public:
    ExperimentalWithRawCallbackMethod_Lock()
    {
      ::grpc::Service::experimental().MarkMethodRawCallback(
          3, new ::grpc::internal::CallbackUnaryHandler<::grpc::ByteBuffer,
                                                        ::grpc::ByteBuffer>(
                 [this](::grpc::ServerContext *context,
                        const ::grpc::ByteBuffer *request,
                        ::grpc::ByteBuffer *response,
                        ::grpc::experimental::ServerCallbackRpcController
                            *controller) {
                   this->Lock(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_Lock() override
    {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status
    Lock(::grpc::ServerContext *context,
         const ::prism::PrismSwitchLockReq *request,
         ::prism::PrismSwitchReply *response) override
    {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void
    Lock(::grpc::ServerContext *context, const ::grpc::ByteBuffer *request,
         ::grpc::ByteBuffer *response,
         ::grpc::experimental::ServerCallbackRpcController *controller)
    {
      controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, ""));
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Unlock : public BaseClass {
  private:
    void
    BaseClassMustBeDerivedFromService(const Service *service)
    {
    }

  public:
    ExperimentalWithRawCallbackMethod_Unlock()
    {
      ::grpc::Service::experimental().MarkMethodRawCallback(
          4, new ::grpc::internal::CallbackUnaryHandler<::grpc::ByteBuffer,
                                                        ::grpc::ByteBuffer>(
                 [this](::grpc::ServerContext *context,
                        const ::grpc::ByteBuffer *request,
                        ::grpc::ByteBuffer *response,
                        ::grpc::experimental::ServerCallbackRpcController
                            *controller) {
                   this->Unlock(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_Unlock() override
    {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status
    Unlock(::grpc::ServerContext *context,
           const ::prism::PrismSwitchLockReq *request,
           ::prism::PrismSwitchReply *response) override
    {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void
    Unlock(::grpc::ServerContext *context, const ::grpc::ByteBuffer *request,
           ::grpc::ByteBuffer *response,
           ::grpc::experimental::ServerCallbackRpcController *controller)
    {
      controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, ""));
    }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Add : public BaseClass {
  private:
    void
    BaseClassMustBeDerivedFromService(const Service *service)
    {
    }

  public:
    WithStreamedUnaryMethod_Add()
    {
      ::grpc::Service::MarkMethodStreamed(
          0,
          new ::grpc::internal::StreamedUnaryHandler<::prism::PrismSwitchAddReq,
                                                     ::prism::PrismSwitchReply>(
              std::bind(&WithStreamedUnaryMethod_Add<BaseClass>::StreamedAdd,
                        this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Add() override
    {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status
    Add(::grpc::ServerContext *context,
        const ::prism::PrismSwitchAddReq *request,
        ::prism::PrismSwitchReply *response) override
    {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status
    StreamedAdd(::grpc::ServerContext *context,
                ::grpc::ServerUnaryStreamer<::prism::PrismSwitchAddReq,
                                            ::prism::PrismSwitchReply>
                    *server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ChangeOwner : public BaseClass {
  private:
    void
    BaseClassMustBeDerivedFromService(const Service *service)
    {
    }

  public:
    WithStreamedUnaryMethod_ChangeOwner()
    {
      ::grpc::Service::MarkMethodStreamed(
          1,
          new ::grpc::internal::StreamedUnaryHandler<
              ::prism::PrismSwitchChangeOwnerReq, ::prism::PrismSwitchReply>(
              std::bind(&WithStreamedUnaryMethod_ChangeOwner<
                            BaseClass>::StreamedChangeOwner,
                        this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ChangeOwner() override
    {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status
    ChangeOwner(::grpc::ServerContext *context,
                const ::prism::PrismSwitchChangeOwnerReq *request,
                ::prism::PrismSwitchReply *response) override
    {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedChangeOwner(
        ::grpc::ServerContext *context,
        ::grpc::ServerUnaryStreamer<::prism::PrismSwitchChangeOwnerReq,
                                    ::prism::PrismSwitchReply>
            *server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Delete : public BaseClass {
  private:
    void
    BaseClassMustBeDerivedFromService(const Service *service)
    {
    }

  public:
    WithStreamedUnaryMethod_Delete()
    {
      ::grpc::Service::MarkMethodStreamed(
          2, new ::grpc::internal::StreamedUnaryHandler<
                 ::prism::PrismSwitchDeleteReq, ::prism::PrismSwitchReply>(
                 std::bind(
                     &WithStreamedUnaryMethod_Delete<BaseClass>::StreamedDelete,
                     this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Delete() override
    {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status
    Delete(::grpc::ServerContext *context,
           const ::prism::PrismSwitchDeleteReq *request,
           ::prism::PrismSwitchReply *response) override
    {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status
    StreamedDelete(::grpc::ServerContext *context,
                   ::grpc::ServerUnaryStreamer<::prism::PrismSwitchDeleteReq,
                                               ::prism::PrismSwitchReply>
                       *server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Lock : public BaseClass {
  private:
    void
    BaseClassMustBeDerivedFromService(const Service *service)
    {
    }

  public:
    WithStreamedUnaryMethod_Lock()
    {
      ::grpc::Service::MarkMethodStreamed(
          3,
          new ::grpc::internal::StreamedUnaryHandler<
              ::prism::PrismSwitchLockReq, ::prism::PrismSwitchReply>(
              std::bind(&WithStreamedUnaryMethod_Lock<BaseClass>::StreamedLock,
                        this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Lock() override
    {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status
    Lock(::grpc::ServerContext *context,
         const ::prism::PrismSwitchLockReq *request,
         ::prism::PrismSwitchReply *response) override
    {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status
    StreamedLock(::grpc::ServerContext *context,
                 ::grpc::ServerUnaryStreamer<::prism::PrismSwitchLockReq,
                                             ::prism::PrismSwitchReply>
                     *server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Unlock : public BaseClass {
  private:
    void
    BaseClassMustBeDerivedFromService(const Service *service)
    {
    }

  public:
    WithStreamedUnaryMethod_Unlock()
    {
      ::grpc::Service::MarkMethodStreamed(
          4,
          new ::grpc::internal::StreamedUnaryHandler<
              ::prism::PrismSwitchLockReq, ::prism::PrismSwitchReply>(std::bind(
              &WithStreamedUnaryMethod_Unlock<BaseClass>::StreamedUnlock, this,
              std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Unlock() override
    {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status
    Unlock(::grpc::ServerContext *context,
           const ::prism::PrismSwitchLockReq *request,
           ::prism::PrismSwitchReply *response) override
    {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status
    StreamedUnlock(::grpc::ServerContext *context,
                   ::grpc::ServerUnaryStreamer<::prism::PrismSwitchLockReq,
                                               ::prism::PrismSwitchReply>
                       *server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_Add<WithStreamedUnaryMethod_ChangeOwner<
      WithStreamedUnaryMethod_Delete<WithStreamedUnaryMethod_Lock<
          WithStreamedUnaryMethod_Unlock<Service>>>>>
      StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_Add<WithStreamedUnaryMethod_ChangeOwner<
      WithStreamedUnaryMethod_Delete<WithStreamedUnaryMethod_Lock<
          WithStreamedUnaryMethod_Unlock<Service>>>>>
      StreamedService;
};

} // namespace prism

#endif // GRPC_prism_5fswitch_2eproto__INCLUDED
